# 三周目
## 标准

---

> #### O03 数组中重复的数字
>> - 萝卜坑
>> - ~~排序~~
>> - HashTable  
---
> #### O04 二维数组中查找
>> - 以左下角 或者 右上角 为起点 flag
>>     - 若 target > flag 则 可以消去一列
>>     - 若 target < flag 则 可以消去一行
---
> #### ~~O05 替换空格~~
---
> #### ~~O06 倒序打印链表~~
>> - ~~辅助栈~~
>> - 递归 ` return self.reversePrint(head.next) + [head.val] if head else [] `
---
> #### O07 通过前序遍历和中序遍历重建二叉树
>> ```
>> buildTree(data)
>>     if len(data) == 0: return None
>>     ans = TreeNode(data)
>>     ans.left = buildTree(leftdata)
>>     ans.right = buildTree(rightdata)
>>  ```
---
> #### ~~O09 用两个栈实现队列~~
---
> #### ~~O10-I 斐波那契数列~~
---
> #### ~~O10-II 青蛙跳台阶~~
---
> #### O11 旋转数组的最小数字 
>> - ~~顺序遍历寻找逆序对~~
>> - 二分查找
>>     - left <= (left + right) // 2 < right
>>     - 特例 \[1, 2, 3..., max] 旋转了 0 或者 全部 元素 需要  right 被向左拉
---
> #### O12 矩阵 DFS 
>> - 带 擦涂标记 的 dfs
>> ```
>> dfs(params):
>>     temp = data[x][y]
>>     data[x][y] = '/'
>>     ans = dfs(↑) or dfs(↓) or dfs(←) or dfs(→)
>>     date[x][y] = temp
>>     return ans
>> ```
---
> #### O13 矩阵 BFS
>> - Tips 1: 矩阵的 bfs 和 树结构的 bfs 略有不同 
>>     - 树 queue.put() 的元素 不会和 queue 里原有的元素重复
>>     - 矩阵 0,1 ↓ == 1,0 →
>> - Tips 2: set() 集合去重 
>>     - appearInQueue = set() 入队去重 
>>     - ans = set() 答案去重        _choice one in Tips 2_
>> ```
>> bfs(params):
>>     q = Queue()
>>     q.put(initData)
>>     while not q.empty():
>>         data = q.get()
>>         ...do sth about data...
>>         q.put(some data)
>>     return ans
>> ```
---
> #### ~~O014-I 剪绳子~~
>> m 能得到的最大乘积 = max\[（1,m-1) (2,m-2) ... (m/2, m/2) ]  问题的一步简化 m = x + y 转化为 递推
---
> #### ~~O014-II 剪绳子~~
>> 数学 驻点 = 2.7   得到切分规则
---
> #### O15  位运算
>> - & 按位与运算
>> - | 按位或运算
>> - ~ 按位翻转
>> - \>> 1 右移一位   相当于 除以2 取整 // 2
>> - \<< 1 左移一位
---
> #### O16 数值的整数次方 快速幂
>> `(m & 1) == 1`  即可判断奇偶性 妙哉
>> - 当 次数 为 偶数时： x 的 n 次 = x 平方 的 n // 2 次
>> - 当 次数 为 奇数时： x 的 n 次 = x 平方 的 n // 2 次 × 再乘上一个 x     再乘上的部分 暂存在 Ans 里
>> - 最简情况 次数 == 1 时： Ans = Ans * x 
---
> #### O17 打印从1到最大的n位数   大数打印法
>> - 大数表示 通过 String 类型
>> - dfs 生成 全排列
---
> #### ~~O18 删除链表的节点~~
---
> #### O19 正则表达式 动态规划
>> - 麻烦
---
> #### O20 有限状态自动机
>> - 状态转移表 states
>>     - states\[i]  其中 i 为所处状态   states\[i] 为可转移至的状态    
>>         - 即 通过 哈希表 的 键值对 (key, value) ： 若输入 key 则可转移到状态 value  
>> ```
>>      [{转移方式1:状态码1, 转移方式2:状态码2... }, 
>>       {}, 
>>        ...
>>       {}]       其中\[index] 下标也为状态     
>>       状态码 = states[状态码][转移方式]
>> ```
---
> #### ~~O21 数组的奇偶划分~~
>> 首尾双指针
---
> #### ~~O22 链表倒数第k个节点~~
>> 快慢双指针
---
> #### ~~O24 反转链表~~
>> next指针倒转 
---
> #### ~~O25 合并递增链表~~
>> 双指针比较前进 
---
> #### O26 树的子结构 二叉树匹配
>> 遍历框架 加 遍历 check 
---
> #### O27 形成二叉树镜像
>> :d
---
> #### O28 判断二叉树是否为镜像二叉树
>> ;d
---
> #### ~~O29 矩阵顺时针旋转打印~~ 
---
> #### ~~O30 包含min功能的栈~~
---
> #### O31 栈的压入弹出序列是否可行
>> 模拟栈的行为
---
> #### ~~O32-I 二叉树层次打印~~
> #### ~~O32-II 二叉树层次打印~~
> #### ~~O32-III 二叉树层次打印~~
---
> #### O33 二叉搜索树的后续遍历
---
> #### O34 二叉树的路径
>> 二叉树遍历 + 回溯  
---
> #### O35 复杂链表的复制
>> HashTable
---
> #### O36 二叉搜索树转换成排序的循环双向链表
> :d
---
> #### O37 树的序列化和反序列化
>> `queue = collections.deque()`   双端队列
---
> #### O38 字符串的全排列 DFS + BackTrack
>> 难
---
> #### ~~O39 摩尔投票法 找众数~~
---
> #### O40 最小k个数 堆
>> Todo... 2021年3月19日17:16:22
---
> #### O41
---
> #### O42
---
> #### O43








---
> #### ~~O~~
---
> #### O
---