# Again 2020年12月14日19:47:32 动态规划 can u see
"""
把n个骰子扔在地上，所有骰子朝上一面的点数之和为s
输入n，打印出s的所有可能的值出现的概率
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率

示例 1:
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]

示例 2:
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
"""


# 单骰子
#       1 2 3 4 5 6
#       1/6 = 0.16667
#       [1, 1, 1, 1, 1, 1] 然后归一化
# 双骰子
#       [1, 2, 3, 4
# [2,      3,      4,      5,      6,      7,      8,      9,      10,     11,     12     ]
# [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
# n个骰子，一共有6**n种情况
# n = 1 , 和为s的情况有 F(n,s) = 1 s = 1, 2, 3, 4, 5, 6
# n > 1 , F(n,s) = F(n-1,s-1) + F(n-1,s-2) + F(n-1,s-3) + F(n-1,s-4) + F(n-1,s-5) + F(n-1,s-6)
class Solution:
    # def dicesProbability(self, n: int) -> List[float]:
    def dicesProbability(self, n):
        dp = [[0 for _ in range(6 * n + 1)] for _ in range(n + 1)]

        for i in range(1, 7):
            dp[1][i] = 1

        for i in range(2, n + 1):
            # i = 2  3  4 ... n
            for j in range(i, i * 6 + 1):
                # j = 2~12  3~18 ... n~6n
                for k in range(1, 7):
                    if j >= k + 1:
                        # 递推公式
                        dp[i][j] += dp[i - 1][j - k]
                # print(dp)

        res = []
        # 归一化 6**N 即为 sum
        for i in range(n, n * 6 + 1):
            res.append(dp[n][i] * 1.0 / 6 ** n)
        return res


if __name__ == '__main__':
    n = 2
    print(Solution().dicesProbability(n))
